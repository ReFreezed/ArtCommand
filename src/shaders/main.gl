/***************************************************************
*
*  Main shader
*
*---------------------------------------------------------------
*
*  Art Command
*  by Marcus 'ReFreezed' Thunstr√∂m
*
***************************************************************/

uniform bool maskMode;

uniform bool useColorTexture;
uniform bool colorTextureRadial;
uniform Image colorTexture;
uniform vec4 colorTextureLayout; // {scaleX,scaleY, directionX,directionY} // If colorTextureRadial is set, directionX is offsetX.

// vec2 rotate(vec2 v, vec2 angle) {
// 	return vec2(v.x*angle.x-v.y*angle.y, v.x*angle.y+v.y*angle.x);
// }
vec2 rotateCcw(vec2 v, vec2 angle) {
	return vec2(v.x*angle.x+v.y*angle.y, -v.x*angle.y+v.y*angle.x);
}

vec4 effect(vec4 loveColor, Image tex, vec2 texPos, vec2 screenPosPx) {
	vec4 color = Texel(tex, texPos);

	if (useColorTexture) {
		vec2 colorTexPos = texPos;
		colorTexPos      = colorTexPos*2 - 1; // Center.

		if (colorTextureRadial) {
			colorTexPos   /= colorTextureLayout.xy; // Scale.
			vec2 angle     = colorTexPos / length(colorTexPos);
			colorTexPos    = rotateCcw(colorTexPos, angle); // Make radial.
			colorTexPos.x += colorTextureLayout.z; // Offset. (Should be half a pixel.)
			colorTexPos.x  = (colorTexPos.x - .5) * 2;

		} else {
			colorTexPos  = rotateCcw(colorTexPos, colorTextureLayout.zw); // Rotate.
			colorTexPos /= colorTextureLayout.xy; // Scale.
		}

		colorTexPos  = (colorTexPos+1) * .5; // Uncenter.
		color       *= Texel(colorTexture, colorTexPos);

	} else {
		color *= loveColor;
	}

	if (maskMode) {
		return vec4((color.r+color.g+color.b)/3, 0, 0, color.a); // One way of doing it.
	} else {
		return color;
	}
}
